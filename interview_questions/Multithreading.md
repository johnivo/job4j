## Multithreading

[1. Чем отличается процесс от потока?](#1-Чем-отличается-процесс-от-потока)

[2. Каким образом можно создать поток?](#2-Каким-образом-можно-создать-поток)

[3. Как работают методы sleep, yield, wait, notify и notifyAll?](#3-Как-работают-методы-sleep-yield-wait-notify-и-notifyAll)

[4. Объясните следующие термины: монитор, мьютекс, критическая секция?](#4-Объясните-следующие-термины-монитор-мьютекс-критическая-секция)

[5. Как работает join()?](#5-Как-работает-join)

[6. Что такое DeadLock? Приведите примеры.](#6-Что-такое-DeadLock-Приведите-примеры)

[7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap?](#7-Назовите-различия-между-CollectionssynchronizedMapnew-HashMap-и-ConcurrentHashMap)

[8. Различия в интерфейсах Runnable и Callable?](#8-Различия-в-интерфейсах-Runnable-и-Callable)

[9. Различя между isInterrupted(), interrupted()?](#9-Различя-между-isInterrupted-interrupted)

[10. Что происходит при вызове Thread.interrupt()?](#10-Что-происходит-при-вызове-Threadinterrupt)

[11. Перечислите ВСЕ причины по которым может выскочить InterruptedException?](#11-Перечислите-ВСЕ-причины-по-которым-может-выскочить-InterruptedException)

[12. Назовите отличия synchronize{} и ReentrantLock.](#12-Назовите-отличия-synchronize-и-ReentrantLock)

[13. Приведите наиболее существенное отличие между CountDownLatch и Barrier?](#13-Приведите-наиболее-существенное-отличие-между-CountDownLatch-и-Barrier)

[14. Отличие Thread.start() и Thread.run()?](#14-Отличие-Threadstart-и-Threadrun)

[15. Объясните ключевое слово volatile.](#15-Объясните-ключевое-слово-volatile)

[16. Расскажите про приоритеты потока?](#16-Расскажите-про-приоритеты-потока)

[17. Что такое потоки-демоны?](#17-Что-такое-потоки-демоны)

[18. Назовите все возможные состояния потока?](#18-Назовите-все-возможные-состояния-потока)

[19. Что такое race condition?](#19-Что-такое-race-condition)

[20. Что такое Thread Local переменная?](#20-Что-такое-Thread-Local-переменная)

[21. Что такое FutureTask?](#21-Что-такое-FutureTask)

[22. Что такое Thread Pool?](#22-Что-такое-Thread-Pool)

[23. Что такое Semaphore?](#23-Что-такое-Semaphore)

[24. Чем отличается submit от execute у ExecutorServices?](#24-Чем-отличается-submit-от-execute-у-ExecutorServices)

[25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?](#25-Чем-отличается-shutdown-от-shutdownNow-у-ThreadPoolExecutor)

[26. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков?](#26-Как-создать-ThreadPool-у-ExecutorService-только-на-1-на-5-на-неограниченное-количество-потоков)

[27. Что такое ReadWriteLock?](#27-Что-такое-ReadWriteLock)

[28. В чём отличие Thread от FutureTask? В чём отличие Thread.interrupt() и FutureTask.cancel()?](#28-В-чём-отличие-Thread-от-FutureTask-В-чём-отличие-Threadinterrupt-и-FutureTaskcancel)

[29. Расскажите про шаблон проектирования Producer Consumer?](#29-Расскажите-про-шаблон-проектирования-Producer-Consumer)

[30. ](#30-)

## 1. Чем отличается процесс от потока?

Как правило, каждое запущенное приложение состоит из набора взаимодействующих процессов.

**Процесс** - это программа, которая выполняет некоторый код, и у него есть своя область памяти (минимум 1 поток).

**Поток** - это паралельные нити выполнения внутри одного процесса, которые разделяют его общую память.

Еще разок:

**Процесс** - это совокупность кода и данных, разделяющих общее виртуальное адресное пространство.
Процессы изолированы друг от друга, поэтому прямой доступ к памяти чужого процесса невозможен 
(взаимодействие между процессами осуществляется с помощью специальных средств). 
Для каждого процесса ОС создает так называемое «виртуальное адресное пространство», к которому процесс имеет 
прямой доступ. Это пространство принадлежит процессу, содержит только его данные и находится в полном его распоряжении. 
Операционная система же отвечает за то, как виртуальное пространство процесса проецируется на физическую память.

**Поток** («нить» или «трэд») – это одна единица исполнения кода в процессе. Каждый поток последовательно выполняет 
инструкции процесса, которому он принадлежит, параллельно с другими потоками этого процесса.

Процесс может иметь более одного потока для выполнения независимой задачи, например, поток для чтения данных с диска, 
поток для обработки этих данных и другой поток для отправки этих данных по сети. 

Многопоточность - это способ повышения пропускной способности и лучшего использования мощности процессора, т.к. 
потоки исполняются на ядрах процессора. В некоторых OS разница между процессами и потоками сведена к минимуму. 
В контексте Java разница между этими понятиями радикальная (см. классы Thread и Process). 

https://docs.oracle.com/javase/tutorial/essential/concurrency/procthread.html

https://techdifferences.com/difference-between-process-and-thread-in-java.html

[к оглавлению](#Multithreading)

## 2. Каким образом можно создать поток?

+ Создать потомка класса `Thread` и переопределить его метод `run()`;
    ```java
    public class HelloThread extends Thread {
        
        @Override
        public void run() {
            System.out.println("Hello from a thread!");
        }
    
        public static void main(String args[]) {
            (new HelloThread()).start();
        }
    }
    ```
+ Создать объект класса `Thread`, передав ему в конструкторе экземпляр класса, реализующего интерфейс `Runnable`. 
Этот интерфейс содержит метод `run()`, который будет выполняться в новом потоке. Поток закончит выполнение, 
когда завершится его метод `run()`.
    ```java
    public class HelloRunnable implements Runnable {
        
        @Override
        public void run() {
            System.out.println("Hello from a thread!");
        }
    
        public static void main(String args[]) {
            (new Thread(new HelloRunnable())).start();
        }  
    }
    ```

+ Вызвать метод `submit()` у экземпляра класса реализующего интерфейс `ExecutorService`, передав ему в качестве 
параметра экземпляр класса, реализующего интерфейс `Runnable` или `Callable` 
(содержит метод `call()`, в котором описывается логика выполнения).

    ```java
    public class CallableExample {
     
      public static class WordLengthCallable implements Callable {
          private String word;
          public WordLengthCallable(String word) {
              this.word = word;
          }
          public Integer call() {
              return Integer.valueOf(word.length());
          }
      }
     
      public static void main(String args[]) throws Exception {
          ExecutorService pool = Executors.newFixedThreadPool(3);
          Set<Future<Integer>> set = new HashSet<Future<Integer>>();
          for (String word: args) {
              Callable<Integer> callable = new WordLengthCallable(word);
              Future<Integer> future = pool.submit(callable);
              set.add(future);
          }
          int sum = 0;
          for (Future<Integer> future : set) {
              sum += future.get();
          }
          System.out.printf("The sum of lengths is %s%n", sum);
          System.exit(sum);
      }
    }
    ```

https://docs.oracle.com/javase/tutorial/essential/concurrency/runthread.html

[к оглавлению](#Multithreading)

## 3. Как работают методы sleep, yield, wait, notify и notifyAll?

+ `sleep` - усыпляет поток некоторое время, не освобождая lock объект (локи\мониторы\ресурсы).
+ `wait` - усыпляет поток, освобождает lock объект.
+ `notify` - будит последний стоящий в очереди поток.
+ `notifyAll` - будит все стоящие в очереди объекты.
+ `yield` - принудительно передает квант времени следующему потоку, т.е. уступает очередь потокам.

Методы `wait`, `notify` и `notifyAll` класса `Object` позволяют работать с синхронизацией и lock-ами (мониторами) 
на более низком уровне. 
(см. Effective Java и пример Петра https://www.youtube.com/watch?v=6pwM3p2pbic&list=PLW8mAQ8rFUhKFkuXDTb3PT1GKz0T-lCv6&index=13)

[к оглавлению](#Multithreading)

## 4. Объясните следующие термины: монитор, мьютекс, критическая секция?

В многопоточном приложении двум или нескольким потокам может потребоваться одновременный доступ к общему ресурсу, 
что приводит к неожиданному поведению. Примерами таких общих ресурсов являются структуры данных, 
устройства ввода-вывода, файлы и сетевые подключения.
 
**Критическая секция** - часть исполняемого кода программы, которая обращается к общему ресурсу 
(данным или устройству), который не должен быть одновременно использован более чем одним потоком выполнения. 
При нахождении в критической секции двух или более потоков возникает состояние «гонки». 
Чтобы избежать состояния гонки, нужно синхронизировать доступ к критическому разделу.

**Мьютекс** (MUTual EXclusion или взаимное исключение) - это самый простой тип синхронизатора потоков/нитей, который 
гарантирует, что только один поток может одновременно выполнять критический раздел компьютерной программы.
Мьютекс может принимать два состояния – занят и свободен. 

Удобно представлять мьютекс как id захватившего его объекта. Если этот id равен 0 – ресурс свободен. 
Если не 0 – ресурс занят. Можно встать в очередь и ждать его освобождения.

Чтобы получить доступ к критическому разделу, поток получает мьютекс, затем обращается к критическому разделу и, 
наконец, освобождает мьютекс. Тем временем все остальные потоки блокируются до освобождения мьютекса. 
Как только поток выходит из критической секции, другой поток может войти в критическую секцию.

*Задача мьютекса* — защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. 
В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. 
Если другому потоку будет нужен доступ к объекту, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён.

*Цель использования мьютексов* — защита данных от повреждения в результате асинхронных изменений (состояние гонки), 
однако могут порождаться другие проблемы — например взаимная блокировка ([DeadLock](#Что-такое-DeadLock)).

Работать с мютексом в Java можно посредством монитора.
**Монитор** – это высокоуровневая надстройка над мютексом (по факту кусок кода), которая обеспечивает правильную работу с ним. 

В Java монитор реализован с помощью ключевого слова `synchronized`. 
Используется он так: любой нестатический `synchronized`-метод при своем вызове прежде всего пытается захватить монитор 
того объекта, у которого он вызван (на который он может сослаться как на `this`). Если это удалось – метод исполняется. 
Если нет – поток останавливается и ждет, пока монитор будет свободен.

Итого:

**Монитор и мьютекс – это средство обеспечения контроля за доступом к ресурсу.**

**Мьютекс синхронизирует доступ потоков к критической секции, а монитор обеспечивает правильную работу с мьютексом
посредством `synchronized`.**

*Пример из жизни: очередь в туалет, где очередь - это потоки, дверной замок - мьютекс, 
блок электронного управления замком с маячком - монитор, а туалет - критическая секция.*

Когда человек заходит в туалет, он закрывает изнутри дверь на замок.
Туалет выполняет роль объекта, доступ к которому получают несколько потоков. 
Замок на двери туалета — роль мьютекса, а очередь из людей снаружи — роль потоков.
Замок на двери — мьютекс туалета: он гарантирует, что внутри одновременно может находиться только один человек. 
Иными словами, только один поток в определенное время может работать с общими ресурсами. 
Попытки других потоков (людей) получить доступ к занятым ресурсам будут неудачными.

https://www.baeldung.com/java-mutex

https://stackoverflow.com/questions/3362303/whats-a-monitor-in-java

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html

https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html

[к оглавлению](#Multithreading)

## 5. Как работает join()?

`join()` — текущий поток ждет другой поток.

Когда поток A вызывает `join()` для потока B, текущий работающий поток A будет ждать, пока поток B, 
к которому он присоединяется, не будет завершён:
```java
    void join()        
    void join(long millis) 
    void join(long millis, int nanos) 
```

Например, у нас есть основной/родительский тред и порожденные в нем дочерние треды. 
Если мы хотим, чтобы все дочерние треды были закончены до завершения родительского треда, нужно заджойнить их 
в родительский тред. Т.е. родительский тред будет ждать, пока все дочерние треды закончатся.

`join()` может использоваться при параллельном вычислении для больших формул, 
параллельных сортировках - разбиваем дерево и сортируем его отдельно по веткам.

[к оглавлению](#Multithreading)

## 6. Что такое DeadLock Приведите примеры?

**Deadlock или взаимная блокировка** описывает ситуацию, когда два или более потоков заблокированы навсегда, 
ожидая друг друга.

Например, строгое правило вежливости гласит: когда вы кланяетесь другу, вы должны оставаться в поклоне, 
пока ваш друг тоже не поклонится вам. К сожалению, два человека могут поклониться друг другу одновременно.

Синонимом Deadlock называют Livelock, когда все потоки занимаются бесполезной работой и состояние системы 
не меняется с течением времени.

Виды взаимных блокировок:
+ Взаимоблокировки, вызванные порядком наложения блокировок.
+ Взаимоблокировки, вызванные динамическим порядком блокировок (или взаимная блокировка порядка синхронизации)
+ Взаимоблокировки между взаимодействующими объектами.
+ Взаимоблокировки ресурсов.

Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь так: 
1. Если есть возможность, захватывайте не более одной блокировки за один раз.
2. Если необходимо захватить несколько блокировок, попробуйте свести к минимуму число потенциальных взаимодействий 
между блокировками. Т.е. получайте мониторы разделяемых ресурсов в определённом порядке и освобождайте их в обратном порядке.

Диагностика взаимоблокировок:
1. Ограничение взаимоблокировок по времени.
2. Анализ взаимоблокировок с использованием дампов потоков.

Далее подробно.

+ **Взаимоблокировки, вызванные порядком наложения блокировок.**

    Взаимоблокировка в классе LeftRightDeadlock произошла потому, что два потока пытались захватить блокировки в различном 
порядке (different order). Если бы они запрашивали блокировки в одном и том же порядке, не было бы никакой циклической 
зависимости между блокировками и, следовательно, никакой взаимоблокировки бы не произошло.
```java
public class LeftRightDeadlock {
    private final Object left = new Object(); private final Object right = new Object();
        public void leftRight() {
            synchronized (left) {
            synchronized (right) {
                doSomething();
            }
        }
    }
    public void rightLeft() {
        synchronized (right) {
            synchronized (left) {
                doSomethingElse();
            }
        }
    }
}
```

Решение. Программа будет свободна от взаимоблокировок вызванных порядком наложения блокировок, 
если все потоки будут получать необходимые им блокировки в глобально зафиксированном порядке.

+ **Взаимоблокировки, вызванные динамическим порядком блокировок** (или взаимная блокировка порядка синхронизации)
```java
    public void transferMoney(Account fromAccount, Account toAccount, Amount amount) throws InsufficientFundsException {
        synchronized (fromAccount) {
            synchronized (toAccount) {
                if (fromAccount.getBalance().compareTo(amount) < 0)
                    throw new InsufficientFundsException();
                else {
                    fromAccount.debit(amount);
                    toAccount.credit(amount);
                }
            }
        }
    }
```
Данная блокировка вызвана тем, что синхронизация счетов может происходить в разном порядке. 
Например, два потока одновременно вызывают метод transferMoney, один из которых 
производит перемещение из X в Y, а другой-наоборот:
```java
A: transferMoney(myAccount, yourAccount, 10);
B: transferMoney(yourAccount, myAccount, 20);
```

Решение. Соответственно, если ввести некоторый порядок на счетах (это некоторое правило, позволяющее сказать, 
что счет A меньше чем счет B), то проблема будет устранена.

Нужно индуцировать (induce - вызвать) упорядочение блокировок и захватывать их во всем приложении последовательно, в 
соответствии с индуцированным порядком. Одним из способов индуцирования упорядочивания объектов, является использование 
метода `System.identityHashCode`, который возвращает то же значение, которое будет возвращено методом `Object.hashCode`.

+ **Взаимоблокировки между взаимодействующими объектами**

```java
class Plane {
    private Point location, destination;
    private final Dispatcher dispatcher;
    
    public Plane(Dispatcher dispatcher) {
        this.dispatcher = dispatcher;
    }
    public synchronized Point getLocation() {
        return location;
    }
    public synchronized void setLocation(Point location) {
        this.location = location;
        if (location.equals(destination)) {
            dispatcher.requestLanding(this);
        }
    }
}
    
class Dispatcher {
    private final Set<Plane> planes;
    private final Set<Plane> planesPendingLanding;
    
    public Dispatcher() {
        planes = new HashSet<Plane>();
        planesPendingLanding = new HashSet<Plane>();
    }
    public synchronized void requestLanding(Plane plane) {
        planesPendingLanding.add(plane);
    }
    public synchronized Image getMap() {
        Image image = new Image();
        for (Plane plane : planes) {
            image.drawMarker(plane.getLocation());
        }
        return image;
    }
}
```

В результате, если самолет прибывает на место, в тот же момент, как кто-то решает получить карту может возникнуть 
взаимная блокировка. То есть, будут вызваны методы, `getMap` и `setLocation`, которые займут мониторы экземпляров 
`Dispatcher` и `Plane` соответственно. Затем метод `getMap` вызовет `plane.getLocation` (в частности для экземпляра `Plane`, 
который в данный момент занят), который будет ждать освобождения монитора для каждого из экземпляров `Plane`. 
В то же время в методе `setLocation` будет вызван `dispatcher.requestLanding`, 
при этом монитор экземпляра `Dispatcher` остается занят рисованием карты. Результат – взаимная блокировка.

Решение. Используйте открытые вызовы. То есть, вызывать методы других объектов вне синхронизированного блока. 
Если с применением принципа открытых вызовов переписать методы `setLocation` и `getMap`,
 возможность взаимной блокировки будет устранена. Выглядеть это будет, например, так:
```java
public void setLocation(Point location) {
	boolean reachedDestination;
	synchronized(this) {
		this.location = location;
		reachedDestination = location.equals(destination);
	}
	if (reachedDestination) {
		dispatcher.requestLanding(this);
	}
}
………………………………………………………………………………
public Image getMap() {
	Set<Plane> copy;
	synchronized(this) {
		copy = new HashSet<Plane>(planes);
	}
	Image image = new Image();
	for (Plane plane : copy) {
		image.drawMarker(plane.getLocation());
	}
	return image;
}
```

Старайтесь в своей программе использовать открытые вызовы. 
Программы, которые полагаются на открытые вызовы, гораздо легче анализировать на отсутствие взаимоблокировок, 
чем те, которые допускают вызов чужих методов в процессе удержания блокировки.

+ **Взаимоблокировки ресурсов**

Точно так же, как потоки могут попасть в ситуацию взаимоблокировки, когда каждый из них ожидает блокировку, удерживаемую 
другим потоком, и не освобождает свою, они также могут попасть в ситуацию взаимоблокировки при ожидании ресурсов.

Предположим, у вас есть два объединяющих ресурса, например пулы соединений для двух разных баз данных. Пулы ресурсов, 
как правило, реализуются с использованием семафоров для облегчения блокирования, когда пул пуст. 
Если задача требует подключения к обеим базам данных и оба ресурса не всегда запрашиваются в одном и том же порядке, 
поток A может удерживать подключение к базе D1, при ожидании подключения к базе D2, а поток B может удерживать 
подключение к базе D2, при ожидании подключения к базе данных D1. (Чем больше размер пулов, тем реже это происходит; 
если каждый пул имеет N соединений, для возникновения взаимоблокировки требуется N наборов циклически ожидающих потоков 
и множество неудачных моментов времени.)

**Предотвращение взаимоблокировок:**
1. Если есть возможность, захватывайте не более одной блокировки за один раз. Такая программа никогда не столкнется с 
взаимоблокировкой, вызванной порядком захвата блокировок.
2. Если вам необходимо захватить несколько блокировок, упорядочение блокировок должно быть частью дизайна программы: 
попробуйте свести к минимуму число потенциальных взаимодействий между блокировками.

**Диагностика взаимоблокировок:**
1. Блокировки, ограниченные по времени.

    Использование ограниченного по времени захвата блокировки, для захвата нескольких блокировок, может быть эффективным 
    средством против возникновения взаимоблокировки, даже если блокировка по времени используется во всей программе не 
    согласованно. Если время захвата блокировки истекло, вы можете освободить блокировки, отступить и подождать некоторое 
    время, а затем повторить попытку, возможно, очистив условие взаимоблокировки и позволив программе восстановиться. 
    (Этот подход работает только тогда, когда две блокировки захватываются вместе; если несколько блокировок захватываются 
    во вложенных вызовах методов, вы не можете просто освободить внешнюю блокировку, даже если вы знаете о том, что 
    удерживаете ее вы.)

2. Анализ взаимоблокировок с использованием дампов потоков.

    JVM может помочь идентифицировать их, когда они происходят, с помощью использования дампа потоков. Дамп потока 
    содержит трассировку стека для каждого запущенного потока, аналогичную трассировке стека, сопровождающей исключение. 
    Дампы потоков также включают в себя информацию о блокировании, например о том, какие блокировки удерживаются каждым 
    потоком, в каких кадрах стека они были захвачены, и какую блокировку ожидает захватить заблокированный поток. Перед 
    созданием дампа потока, JVM просматривает граф ожидания (is-waiting-for graph) в поисках циклов, для определения 
    наличия взаимоблокировок. Если среда JVM находит цикл, она включает информацию о взаимоблокировке, идентифицирующую, 
    какие блокировки и потоки участвуют, и где в программе нарушен захват блокировки.
    
    Для инициирования сброса дампа потока, можно отправить процессу JVM сигнал SIGQUIT (kill -3) на платформах Unix или 
    нажать комбинацию клавиш Ctrl-\ в Unix или Ctrl-Break на платформах Windows. 
    Многие IDE также могут запросить дамп потока.

гл. 10.1 Взаимоблокировки "Java concurrency in practice" Brian Goetz

https://docs.oracle.com/javase/tutorial/essential/concurrency/deadlock.html

[к оглавлению](#Multithreading)

## 7. Назовите различия между CollectionssynchronizedMap(new HashMap()) и ConcurrentHashMap?

Оба являются синхронизированными версиями HashMap c различиями в функциональности и внутренней структуре. 

SynchronizedMap оборачивает обычный Map используя единственный монитор для блокировки,

тогда как ConcurrentHashMap:
+ позволяет делать неблокирующее чтение (но можно увидеть старые\невалидные данные).
+ на запись делит map на секции, к каждой из которых идет свой объект блокировки (это уменьшает общее время ожидания).

**ConcurrentHashMap** позволяет одновременную модификацию карты из нескольких потоков без необходимости их блокировки.
Операции получения `get` не блокируются, поэтому могут перекрываться с операциями обновления `put` и `remove`.
Считывание происходит очень быстро, в то время как запись выполняется с помощью блокировки. Т.е. несколько потоков 
могут одновременно получить/положить пары key-value из ConcurrentHashMap без блокирования/ожидания друг друга. 

+ На уровне объекта нет блокировки. Блокировка имеет более мелкую детализацию. 
ConcurrentHashMap состоит из внутренних сегментов, которые могут быть заблокированы отдельными потоками, выполняемыми 
одновременно.
+ Эффект блокировки нижнего уровня заключается в том, что одновременно могут быть и читатели и писатели, 
что невозможно для синхронизированных коллекций. Это приводит к гораздо большей масштабируемости.
+ ConcurrentHashMap не бросает ConcurrentModificationException, если один поток пытается изменить его, а другой 
выполняет итерацию по нему. ConcurrentHashMap предоставляет Iterator, который не требует синхронизации, и даже позволяет 
изменять карту во время итерации (но не гарантирует, будут ли возвращены элементы, вставленные во время итерации).
+ ConcurrentHashMap как и Hashtable, в отличие от HashMap, не позволяет использовать `null` в качестве ключа или значения.

**Collections.synchronizedMap(new HashMap())** создает синхронизированную версию HashMap с блокируемым доступом.
Если несколько потоков попытаются получить доступ к synchronizedMap одновременно, то им будет 
разрешено получить/положить по однй паре key-value синхроннизированно. Т.е. пока один поток выполняется, все 
остальные должны ждать, независимо хотят ли они получить или положить данные.

+ Каждый метод синхронизируется с использованием блокировки уровня объекта. 
Таким образом, методы `get` и `put` на synchronizedMap приобретают блокировку.
+ Блокировка всей коллекции снижает производительность, хотя и обеспечивает согласованность (при правильном использовании). 
Пока один поток захватил монитор, ни один другой поток не может использовать коллекцию.
Это не проблема, когда операции вставки или поиска выполняются не интенсивно. 
Однако когда нужно перебирать карту большого размера, это может занять много времени.

гл. 5.2.1 Класс ConcurrentHashMap "Java concurrency in practice" Brian Goetz 

[к оглавлению](#Multithreading)

## 8. Различия в интерфейсах Runnable и Callable?

Runnable не может вернуть результат или бросить Exception, оба — обертки кода для вызова из других потоков.

+ Интерфейс Runnable появиля в Java 1.0, а интерфейс Callable был введен в Java 5.0 в составе библиотеки 
`java.util.concurrent`;
+ Классы, реализующие интерфейс Runnable для выполнения задачи должны реализовывать метод `run()`. 
Классы, реализующие интерфейс Callable - метод `call()`;
+ Метод `run()` является `void` поэтому ничего не возвращает, а метод `call()` возвращает значение типа `V`. 
Интерфейс `Callable<V>` является параметризованным и тип значения, которое будет возврщаться в 
методе `call()`, задается этим параметром `V`.
+ Метод `run()` не может выбрасывать проверяемые исключения, в то время как метод `call()` может.

https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html

[к оглавлению](#Multithreading)

## 9. Различя между isInterrupted(), interrupted()?

Механизм прерывания работы потока в Java реализован с использованием внутреннего флага, известного как статус прерывания. 
Прерывание потока вызовом метода `Thread.interrupt()` устанавливает этот флаг.

Методы `Thread.interrupted()` и `isInterrupted()` позволяют проверить, является ли поток прерванным.

+ Статический метод `Thread.interrupted()` проверяет, был ли установлен флаг прерывания у текущего потока. 
При этом флаг прерывания сбрасывается. Фактически, это еще и ограничивает возможность снять флаг прерывания у 
других тредов (нельзя "украсть" прерывание другого треда). 

+ Нестатический метод `isInterrupted()` проверяет статус прерывания у потока, для которого этот метод был вызван, 
не изменяя флаг состояния (поэтому можно вызывать несколько раз).

[к оглавлению](#Multithreading)

## 10. Что происходит при вызове Threadinterrupt()?

вызов `Thread.interrupt()` устанавливает флаг прерывания потока, либо

+ если поток заблокирован на мониторе, ждет другой поток итп (wait, notify) — вылетит InterruptedException, 
но флаг interrupted потока не поставится.
+ если поток ждет ввод-вывод на InterruptableChannel то тоже вылетит exception.
+ если поток ждет ввод-вывод, то он тут же прекратится и выставится флаг Interrupted.

[к оглавлению](#Multithreading)

## 11. Перечислите ВСЕ причины по которым может выскочить InterruptedException?

Поток ждет в `wait()`, `sleep(…)`, `join()` или заблокирован на длительное время аналогичным вызовом.. 
и из соседнего потока дернули `interrupt()`.

+ Поток прерван во время ожидания на мониторе
+ Поток прерван во время засыпания
+ Поток прерван во время захвата `ReentrantLock` через `lockInterruptibly`
+ Поток прерван во время ожидания в `CountDownLatch` через `await`
+ Поток прерван во время ожидания в `CyclicBarrier` через `await`
+ Поток прерван во время ожидания в `Condition` через `await`
+ Поток прерван во время захвата попытки в `Semaphore` через `acquireUninterruptibly`
+ Поток прерван во время получения значения в `Future` через `get`
+ Поток прерван во время обмена значенимя в `Exchanger` через `exchange`
+ Поток прерван во время блокирующих операций с `BlockingQueue`
+ Поток прерван во время работы с I/O через `InterruptableChannel`

В общем, почти любой блокирующий метод выбрасывает это исключение.

https://docs.oracle.com/javase/8/docs/api/java/lang/InterruptedException.html

[к оглавлению](#Multithreading)

## 12. Назовите отличия synchronize{} и ReentrantLock?

+ `synchronize` — более примитивная конструкция, которая обязывает нас отпустить monitor по окончании секции. 
Таким образом захват\освобождение всегда идут парами и всегда связаны с некоторым блоком кода.
+ `ReentrantLock` — можно захватывать и освобождать мониторы в произвольном порядке, дает гибкость но сложнее сделать 
все правильно. Также есть опция fair — следить ли за «честным» порядком предоставления доступа\времени ожидания 
потоков на мониторе.
+ `ReentrantLock` — лучше масштабируется при росте числа потоков.

В Java 5 появился интерфейс Lock, предоставляющий возможности более эффективного и тонкого контроля блокировки ресурсов.
  
**`ReentrantLock`** – реализация интерфейса Lock с таким же базовым поведением и семантикой, как у synchronized, 
но с расширенными возможностями, такими как опрос о блокировании (lock polling), ожидание блокирования 
заданной длительности и прерываемое ожидание блокировки. Кроме того, он предлагает гораздо более высокую эффективность 
функционирования в условиях жесткой состязательности.

**Блокировка с повторным входом (reentrant)** означает, что есть подсчет сбора данных, связанный с блокировкой, и 
если поток, удерживающий блокировку, снова ее получает, данные отражают увеличение, и тогда для реального 
разблокирования нужно два раза снять блокировку. 

**reentrancy** означает возможность повторного захвата монитора, владельцем которого текущий поток уже является. 
Сильно упрощает код и позволяет делать рекурсивные вызовы, легче избежать deadlock’a.

Это аналогично семантике synchronized: если поток входит в синхронный блок, защищенный монитором, 
который уже принадлежит потоку, то потоку будет разрешено дальнейшее функционирование, и блокировка не будет снята. 
Когда поток выйдет из второго (или последующего) блока synchronized, она будет снята только 
когда он выйдет из первого блока synchronized, в который он вошел под защитой монитора.

```java
    Lock lock = new ReentrantLock();

    lock.lock();
    try { 
        // update object state
    }
    finally {
        lock.unlock(); 
    }
```

+ Реализация ReentrantLock гораздо более масштабируема в условиях состязательности, чем реализация synchronized. 
Это значит, что когда много потоков соперничают за право получения блокировки, общая пропускная способность лучше 
у ReentrantLock, чем у synchronized. JVM требуется меньше времени на установление очередности потоков и 
больше времени на непосредственно выполнение.
+ У ReentrantLock (как и у других реализаций Lock) блокировка должна обязательно сниматься в finally блоке (иначе, если 
защищенный код выбросит исключение, блокировка не будет снята). Используя синхронизацию, JVM гарантирует, что 
блокировка автоматически снимаются.

Вывод: когда состязания за блокировку нет или оно очень мало, то `synchronized` возможно будет быстрее. 
Если присутствует заметное состязание за доступ к ресурсу, то `ReentrantLock` дает преимущество.

https://netjs.blogspot.com/2016/02/difference-between-reentrantlock-and-synchronized-java.html

гл. 13.4 Выбор между synchronized и ReentrantLock "Java concurrency in practice" Brian Goetz

https://docs.oracle.com/javase/tutorial/essential/concurrency/locksync.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantLock.html

[к оглавлению](#Multithreading)

## 13. Приведите наиболее существенное отличие между CountDownLatch и Barrier?

Оба синхронизатора позволяют нитям дожидаться друг друга.
`CountDownLatch` ждет пока количество вызовов `countDown()` не превысит нужное, и тогда разблокирует `await()`.
`CyclicBarrier` накапливает потоки в точке вызова `await()` пока их количество не превысит заданное. 

Т.е. главное различие в том, что использовать «замок» можно лишь единожды - после того, как его счётчик достигнет нуля, 
а «барьер» можно использовать неоднократно, даже после того, как он «сломается».

Подробно:

**CountDownLatch** (замок с обратным отсчетом) предоставляет возможность любому количеству потоков в блоке кода ожидать 
до тех пор, пока не завершится определенное количество операций, выполняющихся в других потоках, перед тем как они будут 
«отпущены», чтобы продолжить свою деятельность. В конструктор `CountDownLatch(int count)` обязательно передается количество 
операций, которое должно быть выполнено, чтобы замок «отпустил» заблокированные потоки. 

Для ожидания по самоблокировке в потоке исполнения вызывается метод `await()`, общие формы которого приведены ниже:
```java
void await() throws InterruptedException
```
в этой форме ожидание длится до тех пор, пока отсчет, связанный с вызывающим объектом типа CountDownLatch, 
не достигнет нуля. 

```java
boolean await(long , TimeUnit _) throws InterruptedException
```
а в этой форме ожидание длится только в течение определенного периода времени, определяемого параметром ожидание.
Метод `await()` возвращает `false`, если достигнут предел времени ожидания, или `true`, если обратный отсчет достигает нуля.

Чтобы известить о событии, следует вызвать метод `countDown()`. Всякий раз, когда вызывается метод `countDown()`, 
отсчет, связанный с вызывающим объектом, уменьшается на единицу.
```java
void countDown()
```

> Примером `CountDownLatch` из жизни может служить сбор экскурсионной группы: пока не наберется определенное количество 
человек, экскурсия не начнется.

**CyclicBarrier** реализует шаблон синхронизации «Барьер». Циклический барьер является точкой синхронизации, 
в которой указанное количество параллельных потоков встречается и блокируется. Как только все потоки прибыли, 
выполняется опционное действие (или не выполняется, если барьер был инициализирован без него), и, после того, 
как оно выполнено, барьер ломается и ожидающие потоки «освобождаются». 

В конструкторы барьера `CyclicBarrier(int parties)` и `CyclicBarrier(int parties, Runnable barrierAction)` обязательно 
передается количество сторон, которые должны «встретиться», и, опционально, действие, которое должно произойти, 
когда стороны встретились, но перед тем когда они будут «отпущены».

> `CyclicBarrier` является альтернативой метода `join()`, который «собирает» потоки только после того, как они выполнились.

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CountDownLatch.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CyclicBarrier.html

[к оглавлению](#Multithreading)

## 14. Отличие Threadstart() и Threadrun()?

`Thread.start()` порождает новый поток, в котором исполняет код `Thread.run()`, т.е.
+ `start()` — стартует нитку.
+ `run()` — стартует код в текущей нитке без порождения отдельного потока.

`Thread.start()` в отличие от `Thread.run()` переводит поток в состояние RUNNABLE и запускает код независимо от текущего потока. 
В случае же вызова `Thread.run()` код выполнит тот же поток, который вызвал этот метод. 

Семантика этих методов совершенно разная: `run()` отвечает за задачу, которую нужно выполнить независимо, 
а `start()` поднимает инфрастуктуру по выполнению этой задачи.

[к оглавлению](#Multithreading)

## 15. Объясните ключевое слово volatile?

```java
private volatile boolean varName; //синтаксис
```

Модификатор `volatile` вынуждает потоки отключить оптимизацию доступа и использовать единственный экземпляр переменной.

*Запись* volatile-переменных производится в основную память (медленную), минуя локальную (кэш). 

*Чтение* volatile-переменной производится также из основной памяти, т.e. значение переменной не может 
сохраняться в регистрах или локальной памяти потока и операция чтения этой переменной гарантированно вернёт 
последнее записанное в неё значение.

Поэтому `volatile` дает гарантии happens-before на все присвоения переменных до текущего момента 
(так называемый read memory barrier).

Внимание!
+ Если переменная примитивного типа, то этого будет достаточно для обеспечения потокобезопасности. 
+ Если переменная является ссылкой на объект, то синхронизировано будет исключительно значение этой ссылки. 
Все же данные, содержащиеся в объекте, синхронизированы не будут.

http://tutorials.jenkov.com/java-concurrency/volatile.html

[к оглавлению](#Multithreading)

## 16. Расскажите про приоритеты потока?

Приоритеты потоков используются планировщиком потоков для принятия решений о том, когда какому из потоков будет 
разрешено работать. Теоретически высокоприоритетные потоки получают больше времени процессора, чем низкоприоритетные. 
На практике объем времени процессора, который получает поток, часто зависит от нескольких факторов помимо его приоритета.
(Например, то, как ОС реализует многозадачность, может влиять на относительную доступность времени процессора)
Поэтому нельзя полагаться на приоритеты для предсказуемого выполнения многопоточной программы!

Чтобы установить приоритет потока, используется метод класса Thread `final void setPriority(int level)`. 
Уровень приоритета варьируется от 1 (наименее важный) до 10 (наиболее важный), а приоритет по умолчанию равен 5.

В классе Thread предусмотрены три константы, определяющие минимальный, максимальный и приоритет по умолчанию для потока.
```java
public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;
```

Получить текущее значение приоритета потока можно вызвав метод `final int getPriority()` у экземпляра класса Thread.

[к оглавлению](#Multithreading)

## 17. Что такое потоки демоны?

В Java есть два типа потоков: пользовательские и потоки-демоны.

Пользовательские потоки являются приоритетными. JVM будет ждать, пока какой-либо пользовательский поток завершит 
свою задачу, прежде чем завершить ее.

Потоки-демоны являются потоками с низким приоритетом. 
Они работают в фоновом режиме и не гарантируют, что они завершатся.
Базовое свойство потоков-демонов заключается в возможности основного потока приложения завершить выполнение 
потока-демона (в отличие от обычных потоков) с окончанием кода метода `main()`, даже если поток-демон еще работает. 
Т.е. если все потоки завершились, то потоки-демоны просто обрывается вместе с закрытием приложения.

Они используются для выполнения фоновых задач, обслуживающих процесс в течение его жизни. 
Например, для сборки мусора, освобождения памяти от неиспользуемых объектов и удаления ненужных записей из кэша. 
Большинство потоков JVM являются потоками-демонами.

Поскольку потоки-демоны предназначены для обслуживания пользовательских потоков и нужны только во время работы 
пользовательских потоков, они не будут препятствовать выходу JVM после завершения всех пользовательских потоков.

Поэтому бесконечные циклы, которые обычно существуют в потоках-демонах, не вызовут проблем: любой код, 
включая блоки `finally`, не будет выполнен, как только все пользовательские потоки закончили выполнение. 
По этой причине потоки-демоны не рекомендуется использовать для задач ввода-вывода.

Однако есть исключения из этого правила. Плохо разработанный код в потоках-демонах может помешать выходу из JVM. 
Например, вызов `Thread.join()` в работающем потоке-демоне может заблокировать завершение работы приложения.

Чтобы объявить поток демоном, нужно перед запуском вызвать у него метод `setDaemon(true);`
Проверить, является-ли поток демоном, можно вызвав его метод `boolean isDaemon();`
```java
NewThread thread = new NewThread();
thread.setDaemon(true);
thread.start();
System.out.println(thread.isDaemon()); //true
```

https://www.baeldung.com/java-daemon-thread

[к оглавлению](#Multithreading)

## 18. Назовите все возможные состояния потока?

Потоки могут находиться в одном из следующих состояний:

+ **Новый (New)** После создания экземпляра потока, он находится в состоянии *Новый* до тех пор, пока не вызван 
метод `start()`. В этом состоянии поток не считается живым.

+ **Работоспособный (Runnable)** Поток переходит в состояние *Работоспособный*, когда вызывается метод `start()`. 
Поток может перейти в это состояние также из состояния *Работающий* или из состояния *Блокирован*. 
Когда поток находится в этом состоянии, он считается живым.

+ **Работающий (Running)** Поток переходит из состояния *Работоспособный* в состояние *Работающий*, 
когда Планировщик потоков выбирает его как работающий в данный момент.

+ **Живой, но не работоспособный (Alive, but not runnable)** Поток может быть живым, но не работоспособным по нескольким причинам:
    + ***Ожидание (Waiting)*** Поток переходит в состояние *Ожидания*, вызывая метод `wait()`. 
    И наоборот вызов `notify()` или `notifyAll()` может перевести поток из состояния *Ожидания* в состояние *Работоспособный*.
    + ***Сон (Sleeping)*** Метод `sleep()` переводит поток в состояние *Сна* на заданный промежуток времени в миллисекундах.
    + ***Блокировка (Blocked)*** Поток может перейти в это состояние, в ожидании ресурса, 
    такого как ввод/вывод или из-за блокировки другого объекта. 
    В этом случае поток переходит в состояние *Работоспособный*, когда ресурс становится доступен.

+ **Мёртвый (Dead)** Поток считается мёртвым, когда его метод `run()` полностью выполнен. 
Мёртвый поток не может перейти ни в какое другое состояние, даже если для него вызван метод `start()`.

[к оглавлению](#Multithreading)

## 19. Что такое race condition?

Модель памяти Java отличается от аппаратной памяти, которая не различает стеки потоков и кучу. 
На уровне железа стек потоков и куча находятся в основной памяти. 
Поэтому могут возникнуть две проблемы:

1. **Shared visibility** Видимость обновлений (записей) потоков в общие переменные.

*Пример shared visibility:* в одном потоке идет выполнение кода по значению флага, а другой меняет флаг.
В итоге получаем вечный цикл, т.к. значение флага берется из кеша. Использование `volatile` гарантирует видимость 
переменной для всех потоков, будет использоваться значение флага только из основной памяти.

2. **Race condition** Состояние гонки возникает в многопоточной среде, когда более одного потока пытаются получить доступ 
к общему ресурсу (изменить, записать) одновременно. 

Race condition возникает между несколькими нитями, когда поток, который должен исполниться вначале, проиграл гонку и первым 
исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерменированные баги. 
Это одни из сложнейших к отлавливанию и воспроизведению багов, из-за беспорядочной природы гонок между нитями. 
Это следствие ошибки проектирования многопоточной системы или приложения, когда его работа напрямую зависит от того, 
в каком порядке выполняются потоки.

Обратите внимание, что состоянием гонки не является, если несколько потоков пытаются 
только прочитать общий ресурс, не пытаясь его изменить.

*Пример race condition:* два потока используют общий ресурс - один объект типа счетчик и одновременно меняют его состояние
Чтобы уйти от состояния гонки, нужно синхронизировать код в критической секции,
в нашем случае синхронизируем метод экземпляра.

Чтобы предотвратить возникновение состояния гонки, нужно чтобы код критической секции выполнялся как атомарная 
инструкция. Т.е. как только один поток выполняет его, никакие другие потоки не могут его выполнить, 
пока первый поток не покинет критическую секцию.

Условия гонки можно избежать путем правильной синхронизации потоков в критических секциях. 
Синхронизация потоков может быть достигнута с использованием синхронизированного блока кода Java. 
Синхронизация потоков также может быть достигнута с помощью других конструкций синхронизации, 
таких как блокировки или атомарные переменные, такие как java.util.concurrent.atomic.AtomicInteger .

Распространённые способы решения:
 
+ Использование локальной копии — копирование разделяемой переменной в локальную переменную потока. 
Этот способ работает, если переменная одна и копирование производится атомарно (за одну машинную команду).
+ Синхронизация - операции над разделяемым ресурсом происходят в синхронизированном блоке (при использовании 
ключевого слова `synchronized`).
+ Комбинирование методов - вышеперечисленные способы можно комбинировать, копируя «опасные» переменные в 
синхронизированном блоке. С одной стороны, это снимает ограничение на атомарность, с другой — позволяет избавиться 
от слишком больших синхронизированных блоков.
 
Очевидных способов выявления и исправления состояний гонки не существует. 
Лучший способ избавиться от гонок — правильное проектирование многозадачной системы.

http://tutorials.jenkov.com/java-concurrency/java-memory-model.html

http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html

[к оглавлению](#Multithreading)

## 20. Что такое Thread Local переменная?

Класс `ThreadLocal` предоставляет абстракцию над переменными, локальными по отношению к потоку исполнения `java.lang.Thread`. 
Он позволяет для одной переменной, иметь различное её значение для каждого из потоков.

У каждого потока - т.е. экземпляра класса `Thread` - есть ассоциированная с ним таблица *ThreadLocal-переменных*. 
Ключами таблицы являются ссылки на объекты класса `ThreadLocal`, а значениями - ссылки на объекты, «захваченные» 
ThreadLocal-переменными, т.е. ThreadLocal-переменные отличаются от обычных переменных тем, что у каждого потока 
свой собственный, индивидуально инициализируемый экземпляр переменной. Доступ к значению можно получить через 
методы `get()` или `set()`.

Например, если мы объявим ThreadLocal-переменную: `ThreadLocal<Object> locals = new ThreadLocal<Object>();`. 
А затем, в потоке, сделаем `locals.set(myObject)`, то ключом таблицы будет ссылка на объект locals, а значением - ссылка 
на объект `myObject`. При этом для другого потока существует возможность «положить» внутрь `locals` другое значение.

Следует обратить внимание, что `ThreadLocal` изолирует именно ссылки на объекты, а не сами объекты. 
Если изолированные внутри потоков ссылки ведут на один и тот же объект, то возможны коллизии.

Так же важно отметить, что т.к. ThreadLocal-переменные изолированы в потоках, то инициализация такой переменной 
должна происходить в том же потоке, в котором она будет использоваться. 
Ошибкой является инициализация такой переменной (вызов метода `set()`) в главном потоке приложения, 
потому как в данном случае значение, переданное в методе `set()`, будет «захвачено» для главного потока, 
и при вызове метода `get()` в целевом потоке будет возвращен `null`.

http://samolisov.blogspot.com/2011/04/threadlocal.html

https://netjs.blogspot.com/2015/07/when-and-how-to-use-thread-local-class-in-java.html

[к оглавлению](#Multithreading)

## 21. Что такое FutureTask?

**`FutureTask`** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 
Этот класс предоставляет базовую реализацию `Future`, с методами для запуска и остановки вычисления, методами для запроса 
состояния вычисления и извлечения результатов. Результат может быть получен только когда вычисление завершено, 
метод получения будет заблокирован, если вычисление ещё не завершено. 
Объекты `FutureTask` могут быть использованы для обёртки объектов `Callable` и `Runnable`. 
Т.к. `FutureTask` реализует `Runnable`, его можно передать в `Executor` на выполнение.

```java
        // создаем 2 future таска для 2х callable объектов
        FutureTask<String> futureTask1 = new FutureTask<String>(callable1);
        FutureTask<String> futureTask2 = new FutureTask<String>(callable2);
 
        // екзекьютор с размером пула в 2 потока
        ExecutorService executor = Executors.newFixedThreadPool(2);
        
        // стартуем
        executor.execute(futureTask1);
        executor.execute(futureTask2);
         
        // выполняем в бесконечном цикле, пока 
        // executor service не закончит выполнение всех future тасков
        while (true) {
            try {
                if(futureTask1.isDone() && futureTask2.isDone()){
                    System.out.println("Done");
                    // заканчиваем работу executor service
                    executor.shutdown();
                    return;
                }
                 
                if(!futureTask1.isDone()){
                // ждем, пока future task не закончит выполнение
                System.out.println("Результат выполнения FutureTask1 = " + futureTask1.get());
                }
                 
                System.out.println("Ждем, пока FutureTask2 не закончит свое выполнение");
                String s = futureTask2.get(200L, TimeUnit.MILLISECONDS);
                if(s !=null){
                    System.out.println("Результат выполнения FutureTask2 = " + s);
                }
            } catch (InterruptedException | ExecutionException e) {
                e.printStackTrace();
            }catch(TimeoutException e){
                //оставим пустым
            }
        }
```

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/FutureTask.html

[к оглавлению](#Multithreading)

## 22. Что такое Thread Pool?

Создание потока является затратной по времени и ресурсам операцией. 
Количество потоков, которое может быть запущено в рамках одного процесса также ограниченно. 
Чтобы избежать этих проблем и в целом управлять множеством потоков более эффективно в Java был реализован 
механизм пула потоков (thread pool), который создаётся во время запуска приложения и в дальнейшем потоки для 
обработки запросов берутся и переиспользуются уже из него. Т.е. появляется возможность не терять потоки, 
сбалансировать приложение по количеству потоков и частоте их создания.

Начиная с Java 1.5 Java API предоставляет фреймворк `Executor`, который позволяет создавать различные типы пула потоков.

**Типы пула потоков:**

+ `Executor` - упрощенный интерфейс пула, содержит один метод для передачи задачи на выполнение;
+ `ExecutorService` - расширенный интерфейс пула, с возможностью завершения всех потоков;
+ `AbstractExecutorService` - базовый класс пула, реализующий интерфейс `ExecutorService`;
+ `Executors` - фабрика объектов связанных с пулом потоков, в том числе позволяет создать основные типы пулов;
+ `ThreadPoolExecutor` - пул потоков с гибкой настройкой, может служить базовым классом для нестандартных пулов;
+ `ForkJoinPool` - пул для выполнения задач типа `ForkJoinTask`;
+ ... и другие.

**Методы `Executors` для создания пулов:**

+ `newCachedThreadPool()` - если есть свободный поток, то задача выполняется в нем, иначе добавляется новый поток в пул. 
Потоки не используемые больше минуты завершаются и удалются и кэша. Размер пула неограничен. 
Предназначен для выполнения множество небольших асинхронных задач;
+ `newCachedThreadPool(ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newFixedThreadPool(int nThreads)` - создает пул на указанное число потоков. Если новые задачи добавлены, 
когда все потоки активны, то они будут сохранены в очереди для выполнения позже. 
Если один из потоков завершился из-за ошибки, на его место будет запущен другой поток. 
Потоки живут до тех пор, пока пул не будет закрыт явно методом shutdown().
+ `newFixedThreadPool(int nThreads, ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newSingleThreadScheduledExecutor()` - однопотоковый пул с возможностью выполнять задачу через указанное время 
или выполнять периодически. Если поток был завершен из-за каких-либо ошибок, то для выполнения следующей задачи 
будет создан новый поток.
+ `newSingleThreadScheduledExecutor(ThreadFactory threadFactory)` - аналогично предыдущему, но с собственной фабрикой потоков;
+ `newScheduledThreadPool(int corePoolSize)` - пул для выполнения задач через указанное время или переодически;
+ `newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory)` - аналогично предыдущему, 
но с собственной фабрикой потоков;
+ `unconfigurableExecutorService(ExecutorService executor)` - обертка на пул, запрещающая изменять его конфигурацию;

http://tutorials.jenkov.com/java-concurrency/thread-pools.html

https://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html

[к оглавлению](#Multithreading)

## 23. Что такое Semaphore?

`Semaphore` – это новый тип синхронизатора: семафор со счётчиком, реализующий шаблон синхронизации Семафор. 
Доступ управляется с помощью счётчика: изначальное значение счётчика задаётся в конструкторе при создании синхронизатора, 
когда поток заходит в заданный блок кода, то значение счётчика уменьшается на единицу, 
когда поток его покидает, то увеличивается. 
Если значение счётчика равно нулю, то текущий поток блокируется, пока кто-нибудь не выйдет из защищаемого блока. 

`Semaphore` используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, например 
подключение к базе данных в пуле.

гл. 5.5.3 Семафоры "Java concurrency in practice" Brian Goetz

http://tutorials.jenkov.com/java-util-concurrent/threadpoolexecutor.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Semaphore.html

[к оглавлению](#Multithreading)

## 24. Чем отличается submit от execute у ExecutorServices?

Оба метода являются способами подачи задачи в пул потоков, но между ними есть небольшая разница:

+ `execute(Runnable command)` определён в интерфейсе `Executor` и выполняет поданную задачу и ничего не возвращает.

+ `submit()` – перегруженный метод, определённый в интерфейсе `ExecutorService`. 
Способен принимать задачи типов `Runnable` и `Callable` и возвращать объект `Future`, который можно использовать 
для контроля и управления процессом выполнения, получения его результата.

[к оглавлению](#Multithreading)

## 25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?

+ `void shutdown()` просто скажет службе исполнителя, что она не может принимать новые задачи, но уже отправленные 
задачи продолжат выполняться.

+ `List<Runnable> shutdownNow()` сделает то же самое и попытается отменить уже отправленные задачи, 
прерывая соответствующие потоки. Возвращает список ожидаемых задач выполнение.

    Если ваши задачи игнорируют прерывание, то `shutdownNow()` будет вести себя точно так же, как и `shutdown()`.

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html

[к оглавлению](#Multithreading)

## 26. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество потоков?

Например, если надо создать пул с 2мя потоками, то делается это так:
```java
ExecutorService service = Executors.newFixedThreadPool(2);
```

Если требуется использовать кэширующий пул потоков, который создает потоки по мере необходимости, 
но переиспользует неактивные потоки (и подчищает потоки, которые были неактивные некоторое время), 
то это задается следующим образом:
```java
ExecutorService service = Executors.newCachedThreadPool();
```

http://tutorials.jenkov.com/java-util-concurrent/executorservice.html

[к оглавлению](#Multithreading)

## 27. Что такое ReadWriteLock?

**`ReadWriteLock`** – это интерфейс расширяющий базовый интерфейс `Lock`. Используется для улучшения производительности 
в многопоточном процессе и оперирует парой связанных блокировок (одна - для операций чтения, другая - для записи). 
Блокировка чтения может удерживаться одновременно несколькими читающими потоками, до тех пор пока не появится записывающий. 
Блокировка записи является эксклюзивеной.

Интерфейс `ReadWriteLock` реализован классом `ReentrantReadWriteLock`, 
который поддерживает до 65535 блокировок записи и до стольки же блокировок чтения.
```java
ReadWriteLock rwLock = new ReentrantReadWriteLock();
Lock rLock = rwLock.readLock();
Lock wLock = rwLock.writeLock();

wLock.lock();
try {
    // exclusive write
} finally {
    wLock.unlock();
}
        
rLock.lock();
try {
    // shared reading
} finally {
    rLock.unlock();
}      
```

http://tutorials.jenkov.com/java-util-concurrent/readwritelock.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReadWriteLock.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/ReentrantReadWriteLock.html

[к оглавлению](#Multithreading)

## 28. В чём отличие Thread от FutureTask В чём отличие Threadinterrupt() и FutureTaskcancel()?

**`FutureTask`** представляет собой отменяемое асинхронное вычисление в параллельном Java приложении. 
Этот класс предоставляет базовую реализацию `Future`, с методами для запуска и остановки вычисления, 
методами для запроса состояния вычисления и извлечения результатов. 
Результат может быть получен только когда вычисление завершено, метод получения будет заблокирован, 
если вычисление ещё не завершено. 
Объекты `FutureTask` могут быть использованы для обёртки объектов `Callable` и `Runnable`. 
Так как `FutureTask` реализует `Runnable`, его можно передать в `Executor` на выполнение.

У `Future` есть метод `Future.cancel(boolean)`, который должен отменить выполнение задачи. 
В недрах реализации `FutureTask` выполняется код:

```java
if (mayInterruptIfRunning) {
    Thread r = runner;
    if (r != null) {
        r.interrupt(); 
    }
}
```

https://habr.com/ru/post/133413/

[к оглавлению](#Multithreading)

## 29. Расскажите про шаблон проектирования Producer Consumer?

Шаблон заключается в разделении потоков по виду их деятельности на поставщиков и потребителей. 
Поставщики и потребители не общаются друг с другом напрямую, вместо этого передавая работу через общую очередь. 

Такой подход позволяет независимо разрабатывать поставщиков и потребителей, так как они не знают друг о друге, 
но знают только формат общения. 

Другое преимущество - возможность поставщиков и потребителей работать на разной скорости: 
медленный потребитель не будет тормозить быстрого поставщика.

[к оглавлению](#Multithreading)

## 30. ?



[к оглавлению](#Multithreading)


## Источники:

http://tutorials.jenkov.com/java-concurrency/index.html

http://tutorials.jenkov.com/java-util-concurrent/index.html

https://docs.oracle.com/javase/tutorial/essential/concurrency/index.html

https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html

"Java concurrency in practice" Brian Goetz

http://www.duct-tape-architect.ru/?p=294#i