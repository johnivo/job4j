## OOP

[1. Что такое ООП?](#1-Что-такое-ООП)

[2. Базовые концепции ООП?](#2-Базовые-концепции-ООП)

[3. Укажите из каких элементов состоит класс?](#3-Укажите-из-каких-элементов-состоит-класс)

[4. Что такое конструктор? Типы конструкторов?](#4-Что-такое-конструктор-Типы-конструкторов)

[5. Можно ли наследовать конструктор?](#5-Можно-ли-наследовать-конструктор)

[6. Что такое перегрузка конструктора?](#6-Что-такое-перегрузка-конструктора)

[7. Что такое статический метод?](#7-Что-такое-статический-метод)

[8. Что такое не статический метод?](#8-Что-такое-не-статический-метод)

[9. Для чего используется ключевое слово this?](#9-Для-чего-используется-ключевое-слово-this)

[10. Какой класс является базовый родительным классов для всех классов?](#10-Какой-класс-является-базовый-родительным-классов-для-всех-классов)

[11. Что такое наследование? Приведите примеры из реальной жизни?](#11-Что-такое-наследование-Приведите-примеры-из-реальной-жизни)

[12. Опишите процесс создания нового объекта.](#12-Опишите-процесс-создания-нового-объекта)

[13. Как вызвать метод из родительского класса?](#13-Как-вызвать-метод-из-родительского-класса)

[14. Что такое переопределение метода?](#14-Что-такое-переопределение-метода)

[15. Можно ли переопределить статический метод?](#15-Можно-ли-переопределить-статический-метод)

[16. Что такое виртуальная функция и используются ли они в Java?](#16-Что-такое-виртуальная-функция-и-используются-ли-они-в-Java)

[17. Что такое перегрузка метода?](#17-Что-такое-перегрузка-метода)

[18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?](#18-Можно-ли-изменить-тип-возвращаемых-тип-данных-при-перегрузке-метода)

[19. Что такое множественное наследование? Как его можно реализовать в Java?](#19-Что-такое-множественное-наследование-Как-его-можно-реализовать-в-Java)

[20. Что такое полиморфизм? Приведите примеры из реальной жизни?](#20-Что-такое-полиморфизм-Приведите-примеры-из-реальной-жизни)

[21. Что такое инкапсуляция?](#21-Что-такое-инкапсуляция)

[22. Как реализована инкапсуляция в Java?](#22-Как-реализована-инкапсуляция-в-Java)

[23. Что такое абстракция?](#23-Что-такое-абстракция)

[24. Как реализована абстракция в Java?](#24-Как-реализована-абстракция-в-Java)

[25. Что такое интерфейс?](#25-Что-такое-интерфейс)

[26. Что такое внутренний класс? Типы внутренних классов?](#26-Что-такое-внутренний-класс-Типы-внутренних-классов)

[27. Что такое анонимный класс?](#27-Что-такое-анонимный-класс)

[28. Для чего используется конструктор в абстрактном классе?](#28-Для-чего-используется-конструктор-в-абстрактном-классе)

[29. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?](#29-Можно-ли-создать-анонимный-класс,-если-в-классе-нет-конструктора-по-умолчанию)

[30. Что такое композиция?](#30-Что-такое-композиция)

[31. Что такое агрегация?](#31-Что-такое-агрегация)

[32. Какие типы исключительных ситуаций бывают?](#32-Какие-типы-исключительных-ситуаций-бывают)

[33. Как обрабатываются исключительные ситуации?](#33-Как-обрабатываются-исключительные-ситуации)

[34. Назовите основные методы класса Object?](#34-Назовите-основные-методы-класса-Object)

[35. ](#35-)

## 1. Что такое ООП?

Подход (методология) к программированию ориентированный на объекты. Представление программы в виде совокупности объектов, 
каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.

Важным элементом ООП является абстракция. Эффективным средством применения абстракции служат иерархические конструкции.
Это позволяет упрощать понимание сложных систем, разбивая их на более управляемые части.

Например, внешне автомобиль выглядит единым объектом. Но внутрион состоит из нескольких подсистем: 
рулевого управления, двигатель, тормоза, аудиосистемы и т.п. 
Каждая из этих подсистем, также собрана из более специализированных узлов. 
Т.е. структуру автомобиля (или любой сложной системы) можно описать с помощью иерархических абстракций.
Это применимо и к компьютерным программам.

Суть ООП - с помощью абстракций организовать данные компьютерной программы в виде объектов, а последовательность этапов 
ее выполнения — в совокупность сообщений, передаваемых между этими объектами. Т.е. каждый из этих объектов описывает 
свое особое поведение. Эти объекты можно считать конкретными сущностями, реагирующими на сообщения, 
предписывающие им выполнить конкретное действие. 

https://oracle-patches.com/coding/3720-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%BE%D0%BF

[к оглавлению](#OOP)

## 2. Базовые концепции ООП?

+ **Инкапсуляция** - свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе. 
Для Java корректно будет говорить, что инкапсуляция это «сокрытие реализации».

+ **Наследование** - свойство системы, позволяющее описать новый класс на основе уже существующего с частично или полностью 
заимствующейся функциональностью. Класс, от которого производится наследование, называется базовым, родительским 
или суперклассом.

+ **Полиморфизм** - свойство системы использовать объекты с одинаковым интерфейсом без информации о типе и внутренней 
структуре объекта.

+ **Абстракция** - выделение значимой информации и исключение из рассмотрения незначимой.

[к оглавлению](#OOP)

## 3. Укажите из каких элементов состоит класс?

Класс состоит из полей (атрибуты) и методов (функции для работы с этими полями). 
Поле (атрибут) класса — это характеристика объекта, содержит его состояние. 
Например для фигуры это может быть название, площадь, периметр.

Класс является ссылочным типом данных. Это шаблон для создания объекта, в свою очередь объект - это экземпляр класса.

Типы полей:

+ локальные переменные - определены внутри методов, конструкторов или иных блоков кода (циклы, итераторы и т.д.)
Они объявляются и уничтожаются по завершении работы метода.

+ переменные экземпляра - доступны в пределах класса и из любого метода, конструктора или иных блоков кода 
конкретного класса (циклы, итераторы и т.д.).

+ статические переменные - объявляются в классе вне любого метода с помощью ключевого слова `static`.

[к оглавлению](#OOP)

## 4. Что такое конструктор Типы конструкторов?

**Конструктор** — это специальный метод, который вызывается при создании нового объекта (всегда вызывается совместно с 
операцией `new`).
 
Конструктор нужен для автоматической инициализации переменных, т.е. он инициализирует объект непосредственно во время создания. 
Имя конструктора совпадает с именем класса, включая регистр, 
а по синтаксису конструктор похож на метод без возвращаемого значения `void`.

Существуют:

+ конструктор по умолчанию или неявный (без параметров - позволяет регулировать, какие параметры и в каком количестве
нужно задать для создания объекта определенного класса).

+ конструктор с параметрами или явный.

[к оглавлению](#OOP)

## 5. Можно ли наследовать конструктор?

Нет, но ему можно передать аргументы с помощью `super`.

В Java подкласс наследует все члены (поля, методы, вложенные классы) из суперкласса.
Конструкторы не являются членами, поэтому они не наследуются, но конструктор суперкласса м.б. вызван из подкласса.

[к оглавлению](#OOP)

## 6. Что такое перегрузка конструктора?

**Перегрузка конструктора** - это создание конструкторов с другим набором аргументов (как по количеству, так 
и по порядку следования).

Перегрузка конструктора позволяет установить различные способы начальной инициализации объектов класса.

Если был создан конструктор, принимающий аргументы, а нам нужен конструктор по умолчанию (без аргументов), 
то его нужно создать явно.

[к оглавлению](#OOP)

## 7. Что такое статический метод?

**Статический метод** - это метод, который можно вызвать без создания объекта, напрямую через имя класса.

[к оглавлению](#OOP)

## 8. Что такое не статический метод?

**Не статический метод** - это метод, для работы которого необходим объект. Т.е. он принадлежит объекту класса и 
может быть вызван с помощью ссылки на данный объект.

Важно:

+ Статичекий метод нельзя переопределять. Он "один" для класса и его наследников.

+ Статические методы могут ссылаться только на статические переменные. Это гарантирует, что во время выполнения нашего 
метода все элементы будут инициализированы и будут работать. Это называется "статическим контекстом".

+ В отличие от локальных переменных статические поля и методы не потокобезопасны в Java.

[к оглавлению](#OOP)

## 9. Для чего используется ключевое слово this?

`this` - это неявный первый параметр любого нестатического метода класса. 
У какого объекта вызывается метод, тот и будет передан в качестве параметра `this`.

соответственно, `this` используется:

1. в теле любого метода для ссылки на текущий объект, чтобы обращаться к полям и методам данного класса. 
Например, когда у переменной экземпляра и переменной метода\конструктора одинаковые имена.
```java
class Student {
    int age;
    Student (int age) {
        this.age = age;
    }
}
```
2. когда нужно вызвать один конструктор из другого (например, конструктор по умолчанию вызывается в параметризированном). 
Вызов `this()` может находиться только в первой строке конструктора.
```java
public class Toy {
    String name;
    int cost;
    String manufacturer;
    int age;

    public Toy(String name, int cost, String manufacturer, int age) {
        this(name, cost, manufacturer);
        this.age = age;
        System.out.println("В конструкторе с четырьмя параметрами");
    }

    public Toy(String name, int cost, String manufacturer) {
        this();
        this.name = name;
        this.cost = cost;
        this.manufacturer = manufacturer;
        System.out.println("В конструкторе с тремя параметрами");
    }

    public Toy() {
        System.out.println("В конструкторе по умолчанию");
    }
}
public class ToyDemo {
    public static void main(String[] args) {
        Toy toy = new Toy("Кукла", 34, "Disney", 3);
    }
}
```
вывод:
```
В конструкторе по умолчанию
В конструкторе с тремя параметрами
В конструкторе с четырьмя параметрами
```

[к оглавлению](#OOP)

## 10. Какой класс является базовый родительным классов для всех классов?

`Object` - корневой класс в иерархии классов Java. 

Все непримитивный типы, включая массивы, наследуют прямо или косвенно от него.
Поэтому ссылочная переменная класса `Object` может ссылаться на объект любого другого класса.

Ключевое слово `super` представляет текущий экземпляр родительского класса.

[к оглавлению](#OOP)

## 11. Что такое наследование Приведите примеры из реальной жизни?

Это когда один объект перенимает все публичные поля и методы другого объекта. 

Автомобили -> Легковые -> Модель1, Модель2.

Млекопитающие -> Киты -> Голубой кит, горбатый кит.

[к оглавлению](#OOP)

## 12. Опишите процесс создания нового объекта?

Объект создается с помощью ключевого слова `new`, которое вызывает конструктор класса, который инициализирует начальное 
состояние объекта.

```java
Book b;         // объявление переменной определенного типа/класса
b = new Book(); // инстационирование/создание (выделение памяти под объект) и инициализация объекта;
```

Кроме конструктора начальную инициализацию объекта можно проводить с помощью инициализатора объекта (блока инициализации). 
Инициализатор выполняется до любого конструктора. Т.е. в инициализатор мы можем поместить код, общий для всех конструкторов.

https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html
https://metanit.com/java/tutorial/3.1.php
https://www.baeldung.com/java-initialization

**Последовательность инициализации блоков класса и его родителя:**
+ Сначала вызываются все статические блоки от первого предка до последнего наследника.
+ Потом попарно вызываются динамический блок инициализации и конструктор в той же последовательности 
(от предка до последнего потомка).

https://ru.stackoverflow.com/questions/629700/%D0%9F%D0%BE%D1%80%D1%8F%D0%B4%D0%BE%D0%BA-%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0-%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%BE%D0%B2-%D1%80%D0%BE%D0%B4%D0%B8%D1%82%D0%B5%D0%BB%D1%8F-%D0%B8-%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0-%D0%BF%D1%80%D0%B8-%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%B8

[к оглавлению](#OOP)

## 13. Как вызвать метод из родительского класса?

Если метод родительского класса переопределен, а нужно вызвать оригинальную версию метода, то нужно 
использовать ключевое слово `super`, которое представляет текущий экземпляр родительского класса.

[к оглавлению](#OOP)

## 14. Что такое переопределение метода?

Это возможность задать методу родительского класса другой функционал. 

При этом сигнатура (имя метода плюс параметры, причем порядок параметров имеет значение) метода и тип возвращаемого 
значения должны совпадать с сигнатурой и типом возврата в базовом классе.

https://habr.com/ru/company/otus/blog/347900/

[к оглавлению](#OOP)

## 15. Можно ли переопределить статический метод?

Нет, статический метод создается при инициализации класса один на все объекты.

[к оглавлению](#OOP)

## 16. Что такое виртуальная функция и используются ли они в Java?

**Виртуальная функция** - это функция (метод), которая может быть переопределена наследником.
 
В Java практически все функции виртуальные (`private` функции не могут быть переопределены в связи с правами видимости)

[к оглавлению](#OOP)

## 17. Что такое перегрузка метода?

**Перегрузка метода** - это наличие в классе нескольких методов с одним именем, но разными наборами параметров.

Перегрузить можно не только метод, но и конструктор.

При вызове перегруженного метода компилятор автоматически определяет нужный вариант метода по его параметрам, которые 
указываются при вызове.

[к оглавлению](#OOP)

## 18. Можно ли изменить тип возвращаемых тип данных при перегрузке метода?

Можно, если списки аргументов отличаются, иначе JVM не поймет какой метод ей нужно вызвать.

Т.е. если меняем тип возвращаемого значения, то мы также должны изменить список аргументов перегружаемого метода.

https://habr.com/ru/company/otus/blog/347900/

[к оглавлению](#OOP)

## 19. Что такое множественное наследование Как его можно реализовать в Java?

Множественное наследование - это наследование класса от нескольких суперклассов одновременно. 

В Java запрещено множественное наследование главным образом из-за ромбовидной проблемы. 

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_1.png)

возникает неоднозначность: если метод класса D вызывает метод класса А (и этот метод не переопределён в классе D), 
а классы B и C по своему переопределили этот метод, то от какого класса его наследовать? от B или C?

В Java множественное наследование поддерживают интерфейсы.

Если есть необходимость использовать методы из двух разных классов, то можно воспользоваться композицией. 
Для этого в третьем классе нужно создать два необходимых объекта, добавить методы, которые 
обращаются к нужным методам этих объектов. И наследоваться от этого класса.

[к оглавлению](#OOP)

## 20. Что такое полиморфизм Приведите примеры из реальной жизни?

Полиморфизм описывают выражением: *Один интерфейс - множество реализаций.* 

**Полиморфизм** - это возможность работать с несколькими типами, как будьто это один и тот же тип, 
в то же время поведение каждого типа будет уникальным в зависимости от его реализации. 

**Примеры:** 
+ Пульт управления один для разных моделей. 
+ Монетоприемник в каком-нибудь продающем автомате. 
+ Цоколь лампочки - это переменная определенного базового типа. Лампочка - созданный объект конкретного класса. 
Лампочки разные - цоколь один.

[к оглавлению](#OOP)

## 21. Что такое инкапсуляция?

**Инкапсуляция** - это сокрытие реализации и отделение его внутреннего представления от внешнего.

Т.е. это скрытие полей объектов, ограничение доступа к определенным методам и полям.

[к оглавлению](#OOP)

## 22. Как реализована инкапсуляция в Java?

+ специальные методы - геттеров и сеттеров.

+ модификаторы доступа - специальные слова, которые определяют доступ к данным.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_2.png)

Например, модификатором доступа private скрываются поля объекта, 
и при необходимости к ним разрешается подкотрольный доступ через геттеры и сеттеры.

[к оглавлению](#OOP)

## 23. Что такое абстракция?

Абстракция - это выделение значимой информации и исключение из рассмотрения незначимой. 

С помощью принципа абстракции программа разбивается на объекты. 
Информация в программе обрабатывается в виде цепочки действий между отдельными объектами. 

Главное достоинство абстракции связано с тем, что она позволяет отделить реализацию объектов от их описания.

**Пример:** описание узлов в автомобиле. Здесь название узла значимая информация, 
а описание обязанностей у каждого узала это второстепенная информация. 
Наример, главной характеристикой для трансмиссии будет то, что этот узел передает крутящий момент от двигателя колесам, 
а как именно (механика, автомат, робот) это уже второстепенная информация (это вопрос конкретной реализации).

[к оглавлению](#OOP)

## 24. Как реализована абстракция в Java?

С помощью абстрактных классов и интерфейсов.

Абстрактные классы позволяют описать общее поведение и задать особенное поведение для классов наследников.

+ поля - содержат состояние объекта;
+ конструктор - инициализирует начальное состояние объекта;
+ абстрактные методы - не содержат реализации, а декларируют, что данный метод будет иметь реализацию в наследуемом классе;
+ методы - позволяют выполнять действия над объектом.
```java
public abstract class BaseAction {
    private final int key;
    private final String name;
    
    protected BaseAction(final int key, final String name) {
        this.key = key;
        this.name = name;
    }
    
    public abstract void execute(Input input, Tracker tracker);
    
    public String info() {
        return String.format("%s:%s", this.key, this.name);
    }
}
```

применение:
```java
public class AddItem extends BaseAction {
    public AddItem(int key, String name) {
        super(key, name);
    }
    
    @override
    public abstract void execute(Input input, Tracker tracker) {
        String name = input.ask("Enter name:");
        String desc = input.ask("Enter descriotion:");
        tracker.add(new Item(name, desc));
    }
}
```

+ Чтобы создать абстрактный класс нужно использовать ключевое слово `abstract` перед именем класса. 

+ Нельзя создать объект абстрактного класса.

+ В таком классе могут быть абстрактные методы, которые обязан реализовать дочерний класс.
Абстрактные методы могут быть только в абстрактном классе. 

+ В абстрактном классе можно создавать обычные методы. 
Они наследуются также, как и для неабстрактных классов.

[к оглавлению](#OOP)

## 25. Что такое интерфейс?

Интерфейсы задают описание, как должен работать объект. Интерфейсы не содержат реализации.

+ поля - константы `public static final`;
+ абстрактные методы - задают то, как должен работать наш объект, но не определяют как конкретно;
+ статические методы - можем добавлять с Java 8 как обычные `static` методы.
```java
public interface Input {
    
    String LOG = "LOG";
    
    String ask(String question);
   
}
```

Это тип данных, который может содержать лишь константы (статические поля), абстрактные методы, а также начиная 
с Java 8 неабстрактные методы `default` и `static`. 

Также с Java 8 появилась возможность реализовывать методы с дефолтной реализацией, но опять же без конкретного состояния. 
Используется для обращения к абстрактному методу и получению из него информации о конкретной реализации.
```java
public interface Figure {
    Cell position;
    
    Cell[] way(Cell source, Cell dest); 
    
    //можем обратиться к абстрактному методу way и из него получить данные о конкретном состоянии
    default String icon() {
        return String.format(
        "%s.png", this.getClass().getSimpleName()
        );
    }
    
    Figure copy(Cell dest);
}
```
 
У интерфейсов нет конструкторов. 
 
Инерфейс позволяет создавать общий тип данных для разных объектов, т.е. использование интерфейса гарантирует 
наличие определенного метода у объекта.
 
При реализации интерфейса класс реализовать все его методы, иначе он должен быть помечен как `abstract`.
 
Если у интерфейса только один абстрактный метод, перед нами функциональный интерфейс.  
 
**Абстрактный класс vs интерфейс**
 
1. Абстрактный класс содержит состояние объекта, что в интерфейсе невозможно,
т.к. поля там являются константами

2. Наследовать `extends` можно только один абстрактный класс, а реализовать `implements` интерфейсов сколько угодно. 
Интерфейс может наследовать другой интерфейс.

3. В интерфейсах нет конструкторов.

Замечание: 

Абстрактные классы используются, когда есть отношение `is-a`, т.е. класс наследник расширяет базовый абстрактный класс.
 Интерфейс же могут быть реализованы разными классами, вовсе не связанными друг с другом.

Поэтому код, написанный на интерфейсах более масштабируем и его легче поддерживать.
При использовании абстрактных классов, а это всегда наследование, мы связываем наш код.

[к оглавлению](#OOP)

## 26. Что такое внутренний класс Типы внутренних классов?

**Вложенный класс** - это класс, который находится внутри класса или интерфейса.

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_4.png)

+ **Статические**, пример StaticInnerClass:
```java
public class OuterClass { 
    //определены внутри класса
    public static class StaticInnerClass{ 
    } 
} 

//создание экземпляра класса 
OuterClass.StaticInnerClass staticInnerClass = new OuterClass.StaticInnerClass();
```

+ **Нестатические** вложенные в другой класс - это **внутренние классы**.

    + внутренние классы-члены, пример InnerClass:
    ```java
    public class OuterClass { 
         //определены внутри класса
        public class InnerClass{ } 
    } 
    
    //создание экземпляра класса 
    OuterClass outerClass = new OuterClass(); 
    OuterClass.InnerClass innerClass = outerClass.new InnerClass();
    ```

    + локальные классы, пример LocalClass:
    ```java
    public class OuterClass { 
        
        public void someMethod() { 
            
            //определены внутри метода или блока кода
            class LocalClass{}  
        }       
    }
    ```

    + анонимные классы, пример:
    ```java
    public class OuterClass { 
        
        public void someMethod() { 
            
            Callable callable = new Callable() { 
                @Override 
                public Object call() throws Exception { 
                    return null; 
                } 
            };            
        }         
    }
    ``` 

https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html    
https://habr.com/ru/post/439648/

[к оглавлению](#OOP)

## 27. Что такое анонимный класс?

**Анонимный класс** - это класс, который сразу создается и реализуется (без имени класса) от суперкласса или интерфейса.

[к оглавлению](#OOP)

## 28. Для чего используется конструктор в абстрактном классе?

Для инициализации начальных значений общих переменных, объявленных в абстрактном классе и используемых различными реализациями.

[к оглавлению](#OOP)

## 29. Можно ли создать анонимный класс, если в классе нет конструктора по умолчанию?

При создании анонимного класса в скобках можно передать аргументы для недефолтового конструктора.

[к оглавлению](#OOP)

## 30. Что такое композиция?

**Ассоциация** - это отношение, при котором объекты одного типа определенным образом связаны с объектами другого типа. 
Так объект одного типа может содержать или использовать объект другого типа. 

Например, когда один класс включает в себя другой класс в качестве одного из полей. Ассоциация описывается словом «имеет». 
Автомобиль имеет двигатель.

Выделяют два частных случая ассоциации: композицию и агрегацию.

**Агрегация** - отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку 
на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Например, когда экземпляр двигателя создается где-то в другом месте кода, 
и передается в конструктор автомобиля в качестве параметра.
```java
class Engine {
    int power;
    
    public Engine(int p) {
       power = p;
    }
}        

class Car {  
    string model = "Audi";
    Engine engine;
    
    public Car(Engine someEngine) {
         this.engine = someEngine;
    }
}

Engine goodEngine = new Engine(360);
Car audi = new Car(goodEngine);
```

**Композиция** - более строгий вариант агрегирования, когда включаемый объект может существовать только как часть 
контейнера. Если контейнер будет уничтожен, то и включённый объект тоже будет уничтожен.

Например, когда двигатель не существует отдельно от автомобиля. Он создается при создании автомобиля и полностью 
управляется автомобилем. В типичном примере, экземпляр двигателя будет создаваться в конструкторе автомобиля.
```java
class Engine {
    
    int power;
    
    public Engine(int p) {
        power = p;
    }
}

class Car {
    
    string model = "Audi"; 
    Engine engine;
    
    public Car() {
        this.engine = new Engine(360);
    }
}
```

[к оглавлению](#OOP)

## 31. Что такое агрегация?

подробнее:

https://habr.com/ru/post/354046/

https://ru.wikipedia.org/wiki/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

http://sergeyteplyakov.blogspot.com/2012/12/vs-vs.html

https://ru.stackoverflow.com/questions/596697/%D0%90%D0%B3%D1%80%D0%B5%D0%B3%D0%B0%D1%86%D0%B8%D1%8F-%D0%B8-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F

http://java-online.ru/java-interview-01.xhtml

[к оглавлению](#OOP)

## 32. Какие типы исключительных ситуаций бывают?

![img](https://github.com/johnivo/job4j/blob/master/interview_questions/src/main/resources/oop_3.png)
 
подробная иерархия исключений по ссылке
http://i.piccy.info/i9/2579c05514d2f6424a63e4d246ffb0ad/1398970263/143501/740281/exceptions.png

**`Throwable`** - суперкласс исключений. в нем вся логика. Остальные подклассы нужны для того, чтобы определить 
тип исключений:
 
+ **`Error` (unchecked)** - неустранимые (как правило) на уровне JVM проблемы. Согласно спецификации Java, 
не следует пытаться обрабатывать их в собственной программе.
https://docs.oracle.com/javase/8/docs/api/java/lang/Error.html 

   *`OutOfMemoryError`* - ошибка переполнения памяти JVM. Программа дополнительную память всё равно не сможет обеспечить для JVM.
   ThreadDeath - вызывается при неожиданной остановке потока посредством метода `Thread.stop()`.
   
   *`StackOverflowError`* - ошибка переполнение стека. Часто возникает в рекурсивных функциях из-за неправильного условия выхода.

+ **`Exception` (checked)** - являются результатом проблем в программе, которые в принципе решаемые и предсказуемые.
Они обязательны для обработки и обычно связаны с бизнес-логикой приложения.

    + ***`IOException` (checked)*** ошибки созданные неудачными или прерванными операциями ввода-вывода.
    https://docs.oracle.com/javase/8/docs/api/java/io/IOException.html
    
    + ***`SQLException` (checked)*** ошибки доступа к базе данных или другие ошибки, связанных с работой с базами данных.
    https://docs.oracle.com/javase/8/docs/api/java/sql/SQLException.html
    
    + ***`RuntimeException` (unchecked)*** - результат некорректного программирования, компилятор не требует их обработки. 
    https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html
    
        *`IndexOutOfBoundsException`* - выбрасывается, когда индекс некоторого элемента в структуре данных (массив/коллекция) 
        не попадает в диапазон имеющихся индексов.
        
        *`NullPointerException`* - ссылка на объект, к которому вы обращаетесь хранит `null`.
        
        *`ClassCastException`* – Ошибка приведения типов. Всякий раз при приведении типов делается проверка на 
        возможность приведения (проверка осуществляется с помощью `instanceof`).
        
        *`ArithmeticException`* - бросается когда выполняются недопустимые арифметические операции, например деление на ноль.  

**Проверяемые исключения (checked)** - это те исключения, которые проверяются при компиляции. 
Если вы не обработаете их, вы получите ошибку компиляции.

**Непроверяемые исключения (unchecked)** - это те исключения, которые не проверяются во время компиляции. 
JVM не будет «ругаться», если вы не обработаете такие исключения.

http://javastudy.ru/interview/exceptions/

http://java-online.ru/java-throws.xhtml

http://www.quizful.net/post/java-exceptions#targetText=%D0%98%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D1%8F%20%D0%B8%D1%81%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B9,%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20java.lang.Throwable.&targetText=%D0%9F%D1%80%D1%8F%D0%BC%D1%8B%D0%BC%D0%B8%20%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BD%D0%B8%D0%BA%D0%B0%D0%BC%D0%B8%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20Throwable%20%D1%8F%D0%B2%D0%BB%D1%8F%D1%8E%D1%82%D1%81%D1%8F,%D0%B2%D0%BE%D0%B7%D0%BD%D0%B8%D0%BA%D0%B0%D1%8E%D1%89%D0%B8%D0%B5%20%D0%B2%D0%BE%20%D0%B2%D1%80%D0%B5%D0%BC%D1%8F%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F%20%D0%BF%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F.

[к оглавлению](#OOP)

## 33. Как обрабатываются исключительные ситуации?

В Java есть пять ключевых слов для работы с исключениями:

+ `try` — используется для отметки начала блока кода, который потенциально может привести к ошибке.

+ `catch` — ключевое слово для отметки начала блока кода, предназначенного для перехвата и обработки исключений.
Последовательность блоков catch должна идти от частного к более общему. В противном случае будет ошибка компиляции.

+ `finally` — ключевое слово для отметки начала блока кода, которой является дополнительным. 
Этот блок помещается после последнего блока `catch`. Управление обычно передаётся в блок `finally` в любом случае.

+ `throw` — служит для генерации исключений.

+ `throws` — ключевое слово, которое прописывается в сигнатуре метода, и обозначающее,
 что метод потенциально может выбросить исключение с указанным типом.

Общий вид конструкции для «поимки» исключительной ситуации выглядит следующим образом:

Для обработки исключений используется конструкция `try-catch-finally` и c 7й Java `try-with-resources`. 

**`try-catch-finally`**:
```java
try { 
    //здесь код, который потенциально может привести к ошибке 
} 
catch(SomeException e) { //в скобках указывается класс конкретной ожидаемой ошибки  
    //здесь описываются действия, направленные на обработку исключений 
} 
finally { 
    //выполняется в любом случае (блок finally  не обязателен) 
}
```
Пример 1.
```java
try{ 
    fis = new FileInputStream(fileName); 
} catch (Exception ex) {    
    //... 
} catch (IOException e) { 
    //... 
} 
```
Пример 2. Начиная с Java 7 можно переотлавливать несколько исключений одни блоком catch.
```java
try {  
    //... 
} catch( IOException | SQLException ex ) {  
    logger.log(ex); 
    throw ex; 
} 
```

**`try-with-resources`**:
```java
try(открываем файл и т.п. здесь) {
    //здесь код, который потенциально может привести к ошибке 
}
//после блока файл закроется автоматически.
```

Пример 1.
```java
BufferedReader br = new BufferedReader(new FileReader(path));
   try {
        return br.readLine();
   } finally {
        if (br != null) {
            br.close();
        }
   }
```
Пример 2. Java 7
```java
try (BufferedReader br = new BufferedReader(new FileReader(path)) ) {
    return br.readLine();
}
```

[к оглавлению](#OOP)

## 34. Назовите основные методы класса Object?

+ `public native int hashCode()` — возвращает хеш-код объекта.

+ `public boolean equals(Object obj)` — сравнивает объекты.

+ `public String toString()` — возвращает строковое представление объекта.

+ `public final native Class getClass()` — возвращает в рантайме класс данного объекта.

+ `protected native Object clone() throws CloneNotSupportedException` — клонирование объекта

+ `public final native void notify()` — просыпается один поток, который ждет на "мониторе" данного объекта.

+ `public final native void notifyAll()` — просыпаются все потоки, которые ждут на "мониторе" данного объекта.

+ `public final native void wait(long timeout) throws InterruptedException` — поток переходит в режим ожидания в 
течение указанного времени.

+ `public final void wait() throws InterruptedException` — приводит данный поток в ожидание, пока другой поток 
не вызовет `notify()` или `notifyAll()` методы для этого объекта.

+ `public final void wait(long timeout, int nanos) throws InterruptedException` — приводит данный поток в ожидание, 
пока другой поток не вызовет `notify()` или `notifyAll()` для этого метода, или пока не истечет указанный промежуток времени.

+ `protected void finalize() throws Throwable` — вызывается сборщиком мусора, когда garbage collector определил, 
что ссылок на объект больше нет.

Модификатор `native` сигнализирует о том, что метод реализован в платформо-зависимом коде, часто на языке С.

http://javastudy.ru/interview/java-oop3/

[к оглавлению](#OOP)

## 35. ?



[к оглавлению](#OOP)